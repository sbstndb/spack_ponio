diff --git a/ponio/demos/CMakeLists.txt b/ponio/demos/CMakeLists.txt
index b53705a..b52ce1b 100644
--- a/ponio/demos/CMakeLists.txt
+++ b/ponio/demos/CMakeLists.txt
@@ -27,14 +27,22 @@ foreach(demo IN LISTS demos)
 
     if(${demo} IN_LIST demos_samurai)
         message(STATUS "    - samurai")
+        set(SAMURAI_FLUX_CONTAINER xtensor CACHE STRING "Container to store fluxes" FORCE)
         find_package(samurai)
         target_link_libraries(${demo} samurai::samurai)
 
         find_package(PkgConfig)
         pkg_check_modules(PETSC PETSc)
 
+        find_package(CLI11 REQUIRED)
+        target_link_libraries(${demo} CLI11::CLI11)
+
         if(PETSC_FOUND)
             find_package(MPI)
+            target_include_directories(${demo} PRIVATE ${PETSC_INCLUDE_DIRS})
+            target_compile_options(${demo} PRIVATE ${PETSC_CFLAGS_OTHER})
+            target_link_directories(${demo} PRIVATE ${PETSC_LIBRARY_DIRS})
+            target_link_options(${demo} PRIVATE ${PETSC_LDFLAGS_OTHER})
             target_link_libraries(${demo} ${PETSC_LIBRARIES} ${MPI_LIBRARIES})
         endif()
     endif()
diff --git a/ponio/demos/heat_samurai.cpp b/ponio/demos/heat_samurai.cpp
index e7d2a46..2a66a2e 100644
--- a/ponio/demos/heat_samurai.cpp
+++ b/ponio/demos/heat_samurai.cpp
@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 #include <samurai/field.hpp>
-#include <samurai/hdf5.hpp>
+#include <samurai/io/hdf5.hpp>
 #include <samurai/mr/adapt.hpp>
 #include <samurai/mr/mesh.hpp>
 #include <samurai/schemes/fv.hpp>
@@ -105,19 +105,19 @@ main( int argc, char** argv )
     };
     auto f = [&]( [[maybe_unused]] double t, auto&& u )
     {
-        samurai::make_bc<samurai::Neumann>( u, 0. );
+        samurai::make_bc<samurai::Neumann<1>>( u, 0. );
         samurai::update_ghost_mr( u );
         return f_t( t )( u );
     };
     auto pb = ponio::make_implicit_operator_problem( f, f_t );
 
     // Time step
-    double dt = cfl * samurai::cell_length( max_level ) * samurai::cell_length( max_level );
+    double const dx_min = mesh.cell_length( max_level );
+    double dt          = cfl * dx_min * dx_min;
 
     auto eigmax_computer = [=]( auto&, double, auto&, double )
     {
-        double dx = samurai::cell_length( max_level );
-        return 4. / ( dx * dx );
+        return 4. / ( dx_min * dx_min );
     };
 
     // Range to iterate over solution
@@ -129,7 +129,7 @@ main( int argc, char** argv )
 
     // Prepare MR for solution on iterator
     auto MRadaptation = samurai::make_MRAdapt( it_sol->state );
-    samurai::make_bc<samurai::Neumann>( it_sol->state, 0. );
+    samurai::make_bc<samurai::Neumann<1>>( it_sol->state, 0. );
     MRadaptation( mr_epsilon, mr_regularity );
     samurai::update_ghost_mr( it_sol->state );
 
@@ -139,7 +139,7 @@ main( int argc, char** argv )
     std::cerr << "> time loop" << std::endl;
     while ( it_sol->time < Tf )
     {
-        // samurai::make_bc<samurai::Neumann>( it_sol->state, 0. );
+        // samurai::make_bc<samurai::Neumann<1>>( it_sol->state, 0. );
         //  TODO: add a callback function to make this before each iteration
         for ( auto& ki : it_sol.meth.kis )
         {
